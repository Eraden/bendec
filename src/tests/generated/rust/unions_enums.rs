/** GENERATED BY BENDEC TYPE GENERATOR */
#[allow(unused_imports)]
use serde::{Deserialize, Serialize, Serializer};
use serde_repr::{Deserialize_repr, Serialize_repr};
big_array! { BigArray; }
pub use super::shared::*;
  // primitive built-in: u8

// primitive built-in: u16


#[repr(u16)]
#[derive(Debug, Copy, Clone, PartialEq, Serialize_repr, Deserialize_repr)]
pub enum AnimalKind {
  Zebra = 0x1001,
  Toucan = 0x1002,
}


#[repr(C, packed)]
#[derive(Serialize, Deserialize, Copy, Clone)]
pub struct Zebra {
  pub kind: AnimalKind,
  pub legs: u8,
}


#[repr(C, packed)]
#[derive(Serialize, Deserialize)]
pub struct Toucan {
  pub kind: AnimalKind,
  pub wingspan: u16,
}


#[repr(C, packed)]
pub union Animal {
  pub zebra: Zebra,
  pub toucan: Toucan,
}

impl Serialize for Animal {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where S: Serializer,
  {
    unsafe {
      match &self.zebra.kind {
        AnimalKind::Zebra => self.zebra.serialize(serializer),
        AnimalKind::Toucan => self.toucan.serialize(serializer), 
      }
    }
  }
}

impl Animal {
  pub fn deserialize_json(disc: AnimalKind, data: &str) -> Result<Self, serde_json::Error> {
    use serde_json::from_str;
    match disc {
      AnimalKind::Zebra => from_str(data).map(|v| Animal { zebra: v }),
      AnimalKind::Toucan => from_str(data).map(|v| Animal { toucan: v }),
    }
  }
}

#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Serialize_repr, Deserialize_repr)]
pub enum AnimalKind2 {
  Zebra2 = 0x0001,
  Toucan2 = 0x0002,
}


#[repr(C, packed)]
#[derive(Serialize, Deserialize)]
pub struct Header {
  pub animal_kind: AnimalKind2,
}

#[repr(C, packed)]
#[derive(Serialize, Deserialize)]
pub struct Zebra2 {
  pub header: Header,
  pub legs: u8,
}

#[repr(C, packed)]
#[derive(Serialize, Deserialize)]
pub struct Toucan2 {
  pub header: Header,
  pub wingspan: u16,
}


#[repr(C, packed)]
pub union Animal2 {
  pub zebra_2: Zebra2,
  pub toucan_2: Toucan2,
}

impl Serialize for Animal2 {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where S: Serializer,
  {
    unsafe {
      match &self.zebra_2.header.animal_kind {
        AnimalKind2::Zebra2 => self.zebra_2.serialize(serializer),
        AnimalKind2::Toucan2 => self.toucan_2.serialize(serializer), 
      }
    }
  }
}

impl Animal2 {
  pub fn deserialize_json(disc: AnimalKind2, data: &str) -> Result<Self, serde_json::Error> {
    use serde_json::from_str;
    match disc {
      AnimalKind2::Zebra2 => from_str(data).map(|v| Animal2 { zebra_2: v }),
      AnimalKind2::Toucan2 => from_str(data).map(|v| Animal2 { toucan_2: v }),
    }
  }
}

